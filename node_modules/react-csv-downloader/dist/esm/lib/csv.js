var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const newLine = '\r\n';
const raf = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : process.nextTick;
const makeWrapper = (wrapChar) => (str) => `${wrapChar}${str}${wrapChar}`;
const makeResolver = (resolve, newLineAtEnd) => (content) => {
    if (newLineAtEnd) {
        content.push('');
    }
    resolve(content.join(newLine));
};
const identityMapping = (arr, initialMapping) => arr.reduce((acc, k) => {
    acc[k] = k;
    return acc;
}, initialMapping);
const extractHeaderFromData = (datas) => datas.reduce((acc, v) => (Array.isArray(v) ? acc : identityMapping(Object.keys(v), acc)), {});
const extractHeaderFromColumns = (columns) => columns.reduce((acc, v) => {
    var _a;
    if (typeof v === 'string') {
        acc[v] = v;
    }
    else {
        acc[v.id] = (_a = v.displayName) !== null && _a !== void 0 ? _a : v.id;
    }
    return acc;
}, {});
function toChunks(arr, chunkSize) {
    return [...Array(Math.ceil(arr.length / chunkSize))].reduce((acc, _, i) => {
        const begin = i * chunkSize;
        return acc.concat([arr.slice(begin, begin + chunkSize)]);
    }, []);
}
const createChunkProcessor = (resolve, wrap, content, datas, columnOrder, separator, chunkSize) => {
    const chunks = toChunks(datas, chunkSize);
    let i = 0;
    return function processChunk() {
        if (i >= chunks.length) {
            resolve(content);
            return;
        }
        const chunk = chunks[i];
        i += 1;
        chunk
            .map((v) => (Array.isArray(v) ? v : columnOrder.map((k) => { var _a; return (_a = v[k]) !== null && _a !== void 0 ? _a : ''; })))
            .forEach((v) => {
            content.push(v.map(wrap).join(separator));
        });
        raf(processChunk);
    };
};
export default function csv({ columns, datas, separator = ',', noHeader = false, wrapColumnChar = '', newLineAtEnd = false, chunkSize = 1000, }) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((_resolve) => __awaiter(this, void 0, void 0, function* () {
            const resolve = makeResolver(_resolve, newLineAtEnd);
            const wrap = makeWrapper(wrapColumnChar);
            if (typeof datas === 'function') {
                datas = yield datas();
            }
            // it is probably a promise lets await for it
            if (typeof (datas || {}).then === 'function') {
                datas = yield datas;
            }
            const header = columns
                ? extractHeaderFromColumns(columns)
                : extractHeaderFromData(datas);
            const content = [];
            if (!noHeader) {
                const headerNames = Object.values(header);
                if (headerNames.length > 0) {
                    content.push(headerNames.map(wrap).join(separator));
                }
            }
            if (Array.isArray(datas)) {
                const columnOrder = Object.keys(header);
                const processChunk = createChunkProcessor(resolve, wrap, content, datas, columnOrder, separator, chunkSize);
                raf(processChunk);
            }
            else {
                resolve(content);
            }
        }));
    });
}
//# sourceMappingURL=csv.js.map